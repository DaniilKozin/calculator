# üöÄ Zenex RevShare Pool Calculator

[![Streamlit App](https://static.streamlit.io/badges/streamlit_badge_black_white.svg)](https://your-app-name.streamlit.app)

–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –¥–∞—à–±–æ—Ä–¥ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–∏ –ø—É–ª–æ–≤ Zenex —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –ø–µ—Ä–∏–æ–¥–æ–≤ –∏ —Ä–∞—Å—á–µ—Ç–∞ –≤—ã–ø–ª–∞—Ç –∏–Ω–≤–µ—Å—Ç–æ—Ä–∞–º.

## ‚ú® –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏

- üìä **–ê–Ω–∞–ª–∏–∑ –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–∏** Stable –∏ Growth –ø—É–ª–æ–≤
- üí∞ **–†–∞—Å—á–µ—Ç –≤—ã–ø–ª–∞—Ç** per-ZNX –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏—Ä–æ–≤ –∏–Ω–≤–µ—Å—Ç–æ—Ä–æ–≤
- üìà **–ú–µ—Ç—Ä–∏–∫–∏ –±–µ–∑—É–±—ã—Ç–æ—á–Ω–æ—Å—Ç–∏** (295% GGR/Spent, 34% –º–∏–Ω–∏–º—É–º Stable)
- üéõÔ∏è **–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤** —á–µ—Ä–µ–∑ –∏–Ω—Ç—É–∏—Ç–∏–≤–Ω—ã–π UI
- üìÖ **–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö** –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –º–µ—Å—è—Ü–µ–≤
- üîí **High Watermark —Å–∏—Å—Ç–µ–º–∞** –∑–∞—â–∏—Ç—ã –∫–∞–ø–∏—Ç–∞–ª–∞ –∏–Ω–≤–µ—Å—Ç–æ—Ä–æ–≤
- üìã **–≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö** –≤ CSV —Ñ–æ—Ä–º–∞—Ç–µ

## üèÉ‚Äç‚ôÇÔ∏è –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç

### –õ–æ–∫–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫

```bash
# –ö–ª–æ–Ω–∏—Ä—É–π—Ç–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
git clone https://github.com/DaniilKozin/calculator.git
cd calculator

# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
pip install -r requirements.txt

# –ó–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
streamlit run dashboard_app.py
```

–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ –ø–æ –∞–¥—Ä–µ—Å—É: http://localhost:8501

## –î–µ–ø–ª–æ–π –Ω–∞ Streamlit Community Cloud (–ë–ï–°–ü–õ–ê–¢–ù–û)

### –®–∞–≥ 1: –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ GitHub —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è

1. –°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –Ω–∞ [GitHub](https://github.com)
2. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤—Å–µ —Ñ–∞–π–ª—ã –ø—Ä–æ–µ–∫—Ç–∞ (–∫—Ä–æ–º–µ `.venv/` –∏ `__pycache__/`)
3. –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ –≤–∫–ª—é—á–µ–Ω—ã —Ñ–∞–π–ª—ã:
   - `dashboard_app.py`
   - `revshare_pool.py`
   - `requirements.txt`
   - `readme.md`
   - `.gitignore`
   - CSV —Ñ–∞–π–ª—ã —Å –¥–∞–Ω–Ω—ã–º–∏

### –®–∞–≥ 2: –î–µ–ø–ª–æ–π –Ω–∞ Streamlit Cloud

1. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –Ω–∞ [share.streamlit.io](https://share.streamlit.io)
2. –í–æ–π–¥–∏—Ç–µ —á–µ—Ä–µ–∑ GitHub –∞–∫–∫–∞—É–Ω—Ç
3. –ù–∞–∂–º–∏—Ç–µ "New app"
4. –í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
5. –£–∫–∞–∂–∏—Ç–µ:
   - **Main file path**: `dashboard_app.py`
   - **Python version**: 3.9+ (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)
6. –ù–∞–∂–º–∏—Ç–µ "Deploy!"

### –®–∞–≥ 3: –ù–∞—Å—Ç—Ä–æ–π–∫–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)

- –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ –ø–æ URL: `https://your-app-name.streamlit.app`
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö –≤ GitHub
- –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Ö–æ—Å—Ç–∏–Ω–≥ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏:
  - 1 GB RAM
  - 1 CPU core
  - –ó–∞—Å—ã–ø–∞–µ—Ç –ø–æ—Å–ª–µ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏

### –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ)

- **Railway**: [railway.app](https://railway.app) - 500 —á–∞—Å–æ–≤/–º–µ—Å—è—Ü
- **Render**: [render.com](https://render.com) - –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Ç–∏—Ä
- **Heroku**: [heroku.com](https://heroku.com) - –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Ç–∏—Ä

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª–æ–≤

- `dashboard_app.py` - –≥–ª–∞–≤–Ω—ã–π —Ñ–∞–π–ª –¥–∞—à–±–æ—Ä–¥–∞
- `revshare_pool.py` - –ª–æ–≥–∏–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö
- `run.py` - —Å–∫—Ä–∏–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- `requirements.txt` - –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ Python
- CSV —Ñ–∞–π–ª—ã - —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ

## –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ

1. –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤ –±–æ–∫–æ–≤–æ–π –ø–∞–Ω–µ–ª–∏
2. –ù–∞–∂–º–∏—Ç–µ "–ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ"
3. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ –¥–∞—à–±–æ—Ä–¥–µ

## Objective
Create a Python class that generates realistic 365-day casino traffic RevShare Pool data with daily granularity, ensuring all investor tiers achieve positive returns.

## Core Parameters

### Pool Configuration
```python
pool_size: int = 35000  # USD
stable_ratio: float = 0.6  # 60% of pool
growth_ratio: float = 0.4  # 40% of pool
start_date: datetime = "2025-11-01"
duration_days: int = 365
znx_price: float = 0.60  # USD per token
```

### GGR Rates (from generated GGR)
**Stable Pool** (no token return - must return 100%+ capital):
- basic: 34% (100-4,999 ZNX invested)
- advanced: 38.25% (5,000-9,999 ZNX)
- premium: 42.5% (10,000+ ZNX) [CORRECTED from 42%]

**Growth Pool** (100% tokens returned + cash on top):
- basic: 8.5%
- advanced: 10.625%
- premium: 12.75%

### Investor Distribution (apply Pareto principle)
**Use 80/20 rule for realistic distribution:**

Stable Pool:
- basic (34%): 60% of investors, 30% of capital
- advanced (38.25%): 30% of investors, 40% of capital  
- premium (42.5%): 10% of investors, 30% of capital

Growth Pool:
- basic (8.5%): 60% of investors, 30% of capital
- advanced (10.625%): 30% of investors, 40% of capital
- premium (12.75%): 10% of investors, 30% of capital

## Traffic Acquisition (Month 1 Only)

### Traffic Spend Window
- Days 1-30: All traffic budget spent
- Days 31-365: $0 new spend, pure retention

### CPA Parameters
```python
cpa_range: tuple = (55, 75)  # USD, based on real data
# Historical reference: Aug=$54.53, Oct=$69.12, Current=$72.54
# Generate random CPA within range for each cohort
```

### FTD Calculation
```python
total_ftds = traffic_budget / random_cpa
# where random_cpa is uniformly distributed in [55, 75]
# Add daily variance: some days acquire more FTDs than others
```

### First Deposit
```python
first_deposit_range = (20, 28)  # USD
variance = 0.2  # ¬±20% daily variance
```

## Retention Model

### Daily Retention Rates (from FTD date)
```python
retention_schedule = {
    (1, 30): 1.00,      # 100% during first month
    (31, 60): 0.42,     # Month 2: 42% ¬±3%
    (61, 90): 0.33,     # Month 3: 33% ¬±3%
    (91, 120): 0.26,    # Month 4: 26% ¬±2%
    (121, 150): 0.22,   # Month 5: 22% ¬±2%
    (151, 180): 0.19,   # Month 6: 19% ¬±2%
    (181, 210): 0.16,   # Month 7: 16% ¬±2%
    (211, 240): 0.14,   # Month 8: 14% ¬±2%
    (241, 270): 0.12,   # Month 9: 12% ¬±2%
    (271, 300): 0.10,   # Month 10: 10% ¬±1.5%
    (301, 330): 0.09,   # Month 11: 9% ¬±1.5%
    (331, 365): 0.08,   # Month 12: 8% ¬±1%
}
# Apply random variance each day within specified ranges
```

## Average Deposit Growth Model

### Base Deposits by Cohort Age
```python
deposit_by_days = {
    (1, 30): 23,        # First deposits
    (31, 60): 49,       # Early retention
    (61, 90): 66,       # Growing engagement
    (91, 120): 81,      # Established players
    (121, 150): 91,     # Loyal cohort
    (151, 180): 101,    # High value
    (181, 210): 108,    # Whales emerging
    (211, 240): 115,    # Premium players
    (241, 270): 121,    # Top tier
    (271, 300): 125,    # Mature whales
    (301, 330): 129,    # Long-term high rollers
    (331, 365): 132,    # Peak value
}
# Apply variance: base * (0.85 + random(0.30))
```

### Seasonality Multipliers
```python
seasonality = {
    'christmas': {'dates': ['12-20' to '12-31'], 'mult': 1.18},
    'new_year': {'dates': ['01-01' to '01-10'], 'mult': 1.15},
    'valentines': {'date': '02-14', 'mult': 1.08},
    'world_cup': {'months': [6, 7], 'mult': 1.12},  # if applicable
    'summer_peak': {'months': [7, 8], 'mult': 1.06},
    'back_to_school': {'month': 9, 'mult': 0.92},
    'february_slump': {'month': 2, 'mult': 0.94},
    'weekends': {'days': ['Sat', 'Sun'], 'mult': 1.08},
    'paydays': {'dates': ['monthly 25-28'], 'mult': 1.12},
}
```

## GGR Calculation (Critical)

### Daily GGR Formula
```python
daily_deposits = active_players * avg_deposit_for_cohort_age
daily_ggr = daily_deposits * ggr_margin * daily_variance

ggr_margin = 0.88  # 88% house edge (constant)
daily_variance = normal_distribution(mean=1.0, std=0.05)  # ¬±5% daily volatility

# GGR can be NEGATIVE on some days (players win)
# But ensure cumulative GGR trends positive
```

### Target GGR Constraint
```python
# Year-end target: cumulative_ggr ‚âà pool_size √ó 3.0
# Allow variance: actual multiplier between 2.7x - 3.3x
target_ggr_range = (pool_size * 2.7, pool_size * 3.3)

# Use calibration loop to adjust parameters if needed:
# - Tune retention rates
# - Tune deposit growth curve  
# - Tune CPA to get optimal FTD count
```

## Payout Calculations

### Daily Payouts by Pool
```python
# Weighted average rates (based on capital distribution)
stable_weighted_rate = (
    0.30 * 0.34 +      # 30% capital in basic
    0.40 * 0.3825 +    # 40% capital in advanced
    0.30 * 0.425       # 30% capital in premium
) = 0.3808  # ~38.08%

growth_weighted_rate = (
    0.30 * 0.085 +     # 30% capital in basic
    0.40 * 0.10625 +   # 40% capital in advanced
    0.30 * 0.1275      # 30% capital in premium
) = 0.1069  # ~10.69%

daily_stable_payout = max(0, daily_ggr * stable_weighted_rate)
daily_growth_payout = max(0, daily_ggr * growth_weighted_rate)

# Note: If daily_ggr is negative, payouts = 0 for that day
```

### Cumulative Tracking
```python
cumulative_ggr = sum(daily_ggr for all days)
cumulative_stable = sum(daily_stable_payout)
cumulative_growth = sum(daily_growth_payout)

stable_return_pct = (cumulative_stable / stable_pool_size) * 100
growth_return_pct = (cumulative_growth / growth_pool_size) * 100
```

## Output Requirements

### Daily DataFrame Columns
```python
columns = [
    'date',                    # datetime
    'day',                     # 1-365
    'month',                   # 1-12
    'day_of_week',            # Mon-Sun
    'new_ftds',               # int (only Days 1-30)
    'active_players',         # int
    'avg_deposit',            # float
    'total_deposits',         # float
    'daily_ggr',              # float (can be negative!)
    'cumulative_ggr',         # float
    'stable_payout',          # float
    'growth_payout',          # float
    'cumulative_stable',      # float
    'cumulative_growth',      # float
    'stable_return_pct',      # float
    'growth_return_pct',      # float (cash only)
    'traffic_spend',          # float (only Days 1-30)
    'cumulative_traffic',     # float
    'ggr_multiplier',         # cumulative_ggr / pool_size
]
```

### Tier-Level Returns Output
```python
# Must show per-dollar returns for each tier
tier_returns = {
    'stable': {
        'basic': {
            'invested': float,
            'received': float,
            'return_pct': float,  # Must be >100% (includes capital)
            'profit_pct': float,   # Return - 100%
            'per_dollar': float,   # received / invested
        },
        'advanced': {...},
        'premium': {...},
    },
    'growth': {
        'basic': {
            'invested': float,
            'cash_received': float,
            'tokens_returned': float,  # 100% of invested ZNX
            'cash_return_pct': float,
            'total_return_pct': float,  # if ZNX price stays same
            'per_dollar_cash': float,
            'per_dollar_total': float,  # including token value
        },
        'advanced': {...},
        'premium': {...},
    }
}

# VALIDATION: Every tier must show positive returns
# Stable basic (34%): must achieve >100% return
# All others: must show meaningful profit
```

## Class Structure

```python
class RevSharePoolGenerator:
    def __init__(
        self,
        pool_size: int = 35000,
        stable_ratio: float = 0.6,
        growth_ratio: float = 0.4,
        traffic_budget: int = 35000,
        start_date: str = "2025-11-01",
        cpa_range: tuple = (55, 75),
        target_ggr_multiplier: float = 3.0,
        seed: int = None  # for reproducibility
    ):
        """Initialize pool generator with configuration"""
        
    def _calculate_investor_distribution(self) -> dict:
        """Apply Pareto distribution to investor tiers"""
        
    def _generate_ftd_schedule(self) -> pd.DataFrame:
        """Generate FTD acquisition for Days 1-30"""
        
    def _get_retention_rate(self, days_since_ftd: int) -> float:
        """Get retention rate with variance for specific day"""
        
    def _get_avg_deposit(self, days_since_ftd: int, date: datetime) -> float:
        """Calculate average deposit with cohort age and seasonality"""
        
    def _calculate_seasonality(self, date: datetime) -> float:
        """Return seasonality multiplier for given date"""
        
    def _calculate_daily_ggr(self, active_players: int, avg_deposit: float) -> float:
        """Calculate daily GGR with house edge and variance"""
        
    def generate_daily_data(self) -> pd.DataFrame:
        """
        Main generation method - produces 365 days of data
        Returns DataFrame with all required columns
        """
        
    def calibrate_to_target_ggr(self, tolerance: float = 0.1) -> None:
        """
        Iteratively adjust parameters to hit target GGR multiplier
        Tolerance: acceptable deviation from target (e.g., 0.1 = ¬±10%)
        """
        
    def calculate_tier_returns(self) -> dict:
        """
        Calculate final returns for each investor tier
        Ensures all tiers show positive returns
        """
        
    def get_monthly_summary(self) -> pd.DataFrame:
        """Aggregate daily data into monthly view"""
        
    def validate_results(self) -> dict:
        """
        Validate generated data:
        - GGR multiplier in target range
        - All tiers profitable
        - Monotonic cumulative metrics
        - No impossible values
        """
        
    def export_to_csv(self, prefix: str = "pool1") -> None:
        """Export daily data and summaries to CSV files"""
        
    def plot_dashboard(self, save_path: str = None) -> None:
        """
        Create visualization dashboard:
        - Daily GGR over time
        - Active players decay
        - Cumulative returns by pool
        - Tier comparison
        """
```

## Calibration Algorithm

```python
def calibrate_to_target_ggr(self, tolerance=0.1):
    """
    Iterative calibration to achieve target GGR multiplier
    
    Steps:
    1. Generate initial data with default parameters
    2. Check cumulative GGR vs target
    3. If too low: increase retention OR deposits OR FTDs
    4. If too high: decrease retention OR deposits OR FTDs
    5. Repeat until within tolerance
    
    Priority adjustments (in order):
    - FTD count (adjust CPA to control acquisition)
    - Retention rates (boost/reduce by ¬±5%)
    - Deposit growth curve (scale up/down by ¬±10%)
    """
    max_iterations = 20
    for iteration in range(max_iterations):
        daily_data = self.generate_daily_data()
        actual_multiplier = daily_data['cumulative_ggr'].iloc[-1] / self.pool_size
        
        if abs(actual_multiplier - self.target_ggr_multiplier) < tolerance:
            break
            
        # Adjust parameters based on deviation
        # ...
```

## Validation Rules

### Must-Pass Checks
1. **GGR Multiplier**: 2.7x ‚â§ final_ggr/pool_size ‚â§ 3.3x
2. **Stable Returns**: All tiers > 100% (basic must clear 100%+ minimum)
3. **Growth Returns**: All tiers show positive cash + tokens
4. **Monotonic Cumulative**: cumulative_ggr never decreases
5. **Active Players**: Only decrease after Day 30 (no new acquisition)
6. **No Negatives**: No negative active_players or cumulative values
7. **Payout Ratio**: total_payouts < cumulative_ggr (can't pay more than earned)

### Per-Tier Profitability
```python
# Minimum acceptable returns:
stable_basic_min = 1.15      # 115% (100% capital + 15% profit)
stable_advanced_min = 1.22   # 122%
stable_premium_min = 1.30    # 130%

growth_basic_min = 0.15      # 15% cash (plus 100% tokens)
growth_advanced_min = 0.20   # 20% cash
growth_premium_min = 0.27    # 27% cash
```

## Usage Example

```python
# Initialize generator
gen = RevSharePoolGenerator(
    pool_size=35000,
    traffic_budget=35000,
    start_date="2025-11-01",
    cpa_range=(55, 75),
    target_ggr_multiplier=2.9,
    seed=42
)

# Auto-calibrate
gen.calibrate_to_target_ggr(tolerance=0.1)

# Generate data
daily_df = gen.generate_daily_data()
monthly_df = gen.get_monthly_summary()
tier_returns = gen.calculate_tier_returns()

# Validate
validation = gen.validate_results()
assert validation['passed'], f"Validation failed: {validation['errors']}"

# Export
gen.export_to_csv(prefix="pool1_nov2025")

# Print summary
print(f"Final GGR: ${daily_df['cumulative_ggr'].iloc[-1]:,.0f}")
print(f"Multiplier: {daily_df['ggr_multiplier'].iloc[-1]:.2f}x")
print("\nStable Pool Returns:")
for tier, data in tier_returns['stable'].items():
    print(f"  {tier}: {data['return_pct']:.1f}% (${data['per_dollar']:.2f} per $1)")
print("\nGrowth Pool Returns (cash):")
for tier, data in tier_returns['growth'].items():
    print(f"  {tier}: {data['cash_return_pct']:.1f}% + tokens (${data['per_dollar_cash']:.2f} per $1)")
```

## Additional Features

### Scenario Comparison
```python
def compare_scenarios(configs: List[dict]) -> pd.DataFrame:
    """Compare multiple pool configurations side-by-side"""
```

### Sensitivity Analysis
```python
def sensitivity_analysis(parameter: str, range: tuple) -> dict:
    """Test impact of parameter changes on final returns"""
```

### Referral Costs (Optional)
```python
referral_config = {
    'percentage': 0.30,  # 30% of investors via referral
    'upfront_bonus': 0.03,  # 3% of investment
    'monthly_share_stable': 0.04,  # 4% of monthly payout
    'monthly_share_growth': 0.15,  # 15% of monthly payout
}
# Subtract referral costs from business margin
```

---

## üîí –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å

–ü—Ä–æ–µ–∫—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω —Å —É—á–µ—Ç–æ–º –ª—É—á—à–∏—Ö –ø—Ä–∞–∫—Ç–∏–∫ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏:

- ‚úÖ –í—Å–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏—Å–∫–ª—é—á–µ–Ω—ã –∏–∑ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
- ‚úÖ –ù–∞—Å—Ç—Ä–æ–µ–Ω `.gitignore` –¥–ª—è –∑–∞—â–∏—Ç—ã –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
- ‚úÖ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Streamlit –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –¥–ª—è –ø—Ä–æ–¥–∞–∫—à–µ–Ω–∞
- ‚úÖ –û—Ç–∫–ª—é—á–µ–Ω–∞ —Å–±–æ—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

## üìÅ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

```
calculator/
‚îú‚îÄ‚îÄ dashboard_app.py          # –û—Å–Ω–æ–≤–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ Streamlit
‚îú‚îÄ‚îÄ revshare_pool.py         # –õ–æ–≥–∏–∫–∞ —Ä–∞—Å—á–µ—Ç–æ–≤ –ø—É–ª–æ–≤
‚îú‚îÄ‚îÄ requirements.txt         # –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ Python
‚îú‚îÄ‚îÄ readme.md               # –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
‚îú‚îÄ‚îÄ .gitignore              # –ò—Å–∫–ª—é—á–µ–Ω–∏—è Git
‚îú‚îÄ‚îÄ .streamlit/             # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Streamlit
‚îÇ   ‚îú‚îÄ‚îÄ config.toml         # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
‚îÇ   ‚îî‚îÄ‚îÄ secrets.toml        # –°–µ–∫—Ä–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (–Ω–µ –≤ Git)
‚îú‚îÄ‚îÄ project_analysis.md     # –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
‚îî‚îÄ‚îÄ *.csv                   # –ü—Ä–∏–º–µ—Ä—ã –¥–∞–Ω–Ω—ã—Ö
```

## ü§ù –í–∫–ª–∞–¥ –≤ –ø—Ä–æ–µ–∫—Ç

1. –§–æ—Ä–∫–Ω–∏—Ç–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
2. –°–æ–∑–¥–∞–π—Ç–µ –≤–µ—Ç–∫—É –¥–ª—è –Ω–æ–≤–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ (`git checkout -b feature/amazing-feature`)
3. –ó–∞—Ñ–∏–∫—Å–∏—Ä—É–π—Ç–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è (`git commit -m 'Add amazing feature'`)
4. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤ –≤–µ—Ç–∫—É (`git push origin feature/amazing-feature`)
5. –û—Ç–∫—Ä–æ–π—Ç–µ Pull Request

## üìÑ –õ–∏—Ü–µ–Ω–∑–∏—è

–≠—Ç–æ—Ç –ø—Ä–æ–µ–∫—Ç —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è–µ—Ç—Å—è –ø–æ–¥ –ª–∏—Ü–µ–Ω–∑–∏–µ–π MIT. –°–º. —Ñ–∞–π–ª `LICENSE` –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–µ–π.

## üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞

–ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å—ã –∏–ª–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è, —Å–æ–∑–¥–∞–π—Ç–µ [Issue](https://github.com/DaniilKozin/calculator/issues) –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏.

---

## Key Requirements Summary

1. ‚úÖ 365 daily rows with all metrics
2. ‚úÖ GGR can be negative on individual days
3. ‚úÖ Cumulative GGR ~3x pool size (¬±10%)
4. ‚úÖ CPA random in [55, 75] range
5. ‚úÖ Traffic only in Days 1-30
6. ‚úÖ Pareto distribution for investor tiers
7. ‚úÖ All tiers must be profitable
8. ‚úÖ Stable basic (34%) must return >100%
9. ‚úÖ Per-dollar returns for each tier
10. ‚úÖ Auto-calibration to hit target GGR
11. ‚úÖ CSV export capability
12. ‚úÖ Validation checks

Build this class with proper type hints, docstrings, and error handling!